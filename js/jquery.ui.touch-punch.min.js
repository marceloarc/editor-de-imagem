/*!
 * jQuery UI Touch Punch 1.0.8 as modified by RWAP Software
 * based on original touchpunch v0.2.3 which has not been updated since 2014
 *
 * Updates by RWAP Software to take account of various suggested changes on the original code issues
 *
 * Original: https://github.com/furf/jquery-ui-touch-punch
 * Copyright 2011â€“2014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Fork: https://github.com/RWAP/jquery-ui-touch-punch
 *
 * Depends:
 * jquery.ui.widget.js
 * jquery.ui.mouse.js
 */

(function( factory ) {
    if ( typeof define === "function" && define.amd ) {

        // AMD. Register as an anonymous module.
        define([ "jquery", "jquery.ui" ], factory );
    } else {

        // Browser globals
        factory( jQuery );
    }
}(function ($) {

  // Detect touch support - Windows Surface devices and other touch devices
  $.support.mspointer = window.navigator.msPointerEnabled;		
  $.support.touch = ( 'ontouchstart' in document
   	|| 'ontouchstart' in window
   	|| window.TouchEvent
   	|| (window.DocumentTouch && document instanceof DocumentTouch)
   	|| navigator.maxTouchPoints > 0
   	|| navigator.msMaxTouchPoints > 0
  );

  // Ignore browsers without touch or mouse support
  if ((!$.support.touch && !$.support.mspointer) || !$.ui.mouse) {
	return;
  }

  var mouseProto = $.ui.mouse.prototype,
      _mouseInit = mouseProto._mouseInit,
      _mouseDestroy = mouseProto._mouseDestroy,
      touchHandled;

    /**
    * Get the x,y position of a touch event
    * @param {Object} event A touch event
    */
    function getTouchCoords (event) {
        return {
            x: event.originalEvent.changedTouches[0].pageX,
            y: event.originalEvent.changedTouches[0].pageY
        };
    }

  /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
  function simulateMouseEvent (event, simulatedType) {

    // Ignore multi-touch events
    if (event.originalEvent.touches.length > 1) {
      return;
    }

    // Prevent "Ignored attempt to cancel a touchmove event with cancelable=false" errors
    if (event.cancelable) {
      event.preventDefault();
    }

    var touch = event.originalEvent.changedTouches[0],
        simulatedEvent = document.createEvent('MouseEvents');

    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(
      simulatedType,    // type
      true,             // bubbles
      true,             // cancelable
      window,           // view
      1,                // detail
      touch.screenX,    // screenX
      touch.screenY,    // screenY
      touch.clientX,    // clientX
      touch.clientY,    // clientY
      false,            // ctrlKey
      false,            // altKey
      false,            // shiftKey
      false,            // metaKey
      0,                // button
      null              // relatedTarget
    );

    // Dispatch the simulated event to the target element
    event.target.dispatchEvent(simulatedEvent);
  }

  /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
  mouseProto._touchStart = function (event) {

    var self = this;

    // Interaction time
    this._startedMove = event.timeStamp;

    // Track movement to determine if interaction was a click
    self._startPos = getTouchCoords(event);

    // Ignore the event if another widget is already being handled
    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
      return;
    }

    // Set the flag to prevent other widgets from inheriting the touch event
    touchHandled = true;

    // Track movement to determine if interaction was a click
    self._touchMoved = false;

    // Simulate the mouseover event
    simulateMouseEvent(event, 'mouseover');

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');

    // Simulate the mousedown event
    simulateMouseEvent(event, 'mousedown');
  };

  /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
  mouseProto._touchMove = function (event) {

    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }

    // Interaction was moved
    this._touchMoved = true;

    // Simulate the mousemove event
    simulateMouseEvent(event, 'mousemove');
  };

  /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
  mouseProto._touchEnd = function (event) {

    // Ignore event if not handled
    if (!touchHandled) {
      return;
    }

    // Simulate the mouseup event
    simulateMouseEvent(event, 'mouseup');

    // Simulate the mouseout event
    simulateMouseEvent(event, 'mouseout');

    // If the touch interaction did not move, it should trigger a click
    // Check for this in two ways - length of time of simulation and distance moved
    // Allow for Apple Stylus to be used also
    var timeMoving = event.timeStamp - this._startedMove;
    if (timeMoving < 1000) {
        // Simulate the click event
        simulateMouseEvent(event, 'click');
    } else {
      var endPos = getTouchCoords(event);
      if ((Math.abs(endPos.x - this._startPos.x) < 10) && (Math.abs(endPos.y - this._startPos.y) < 10)) {

          // If the touch interaction did not move, it should trigger a click
          if (!this._touchMoved || event.originalEvent.changedTouches[0].touchType === 'stylus') {
              // Simulate the click event
              simulateMouseEvent(event, 'click');
          }
      }
    }

    // Unset the flag to determine the touch movement stopped
    this._touchMoved = false;

    // Unset the flag to allow other widgets to inherit the touch event
    touchHandled = false;
  };

  /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
  mouseProto._mouseInit = function () {

    var self = this;
	  
    // Microsoft Surface Support = remove original touch Action
    if ($.support.mspointer) {
      self.element[0].style.msTouchAction = 'none';
    }	  

    // Delegate the touch handlers to the widget's element
    self.element.on({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });

    // Call the original $.ui.mouse init method
    _mouseInit.call(self);
  };

  /**
   * Remove the touch event handlers
   */
  mouseProto._mouseDestroy = function () {

    var self = this;

    // Delegate the touch handlers to the widget's element
    self.element.off({
      touchstart: $.proxy(self, '_touchStart'),
      touchmove: $.proxy(self, '_touchMove'),
      touchend: $.proxy(self, '_touchEnd')
    });

    // Call the original $.ui.mouse destroy method
    _mouseDestroy.call(self);
  };

}));

function ExpandSelect(select, maxOptionsVisible)
{
	//
	// ExpandSelect 1.00
	// Copyright (c) Czarek Tomczak. All rights reserved.
	//
	// License:
	//	New BSD License (free for any use, read more at http://www.opensource.org/licenses/bsd-license.php)
	//
	// Project's website:
	//	http://code.google.com/p/expandselect/
	//

	if (typeof maxOptionsVisible == "undefined") {
		maxOptionsVisible = 20;
	}
	if (typeof select == "string") {
		select = document.getElementById(select);
	}
	if (typeof window["ExpandSelect_tempID"] == "undefined") {
		window["ExpandSelect_tempID"] = 0;
	}
	window["ExpandSelect_tempID"]++;

	var rects = select.getClientRects();

	// ie: cannot populate options using innerHTML.
	function PopulateOptions(select, select2)
	{
		select2.options.length = 0; // clear out existing items
		for (var i = 0; i < select.options.length; i++) {
			var d = select.options[i];
			select2.options.add(new Option(d.text, i))
		}
	}

	var select2 = document.createElement("SELECT");
	//select2.innerHTML = select.innerHTML;
	PopulateOptions(select, select2);
	select2.style.cssText = "visibility: hidden;";
	if (select.style.width) {
		select2.style.width = select.style.width;
	}
	if (select.style.height) {
		select2.style.height = select.style.height;
	}
	select2.id = "ExpandSelect_" + window.ExpandSelect_tempID;

	select.parentNode.insertBefore(select2, select.nextSibling);
	select = select.parentNode.removeChild(select);

	if (select.length > maxOptionsVisible) {
		select.size = maxOptionsVisible;
	} else {
		select.size = select.length;
	}

	if ("pageXOffset" in window) {
		var scrollLeft = window.pageXOffset;
		var scrollTop = window.pageYOffset;
	} else {
		// ie <= 8
		// Function taken from here: http://help.dottoro.com/ljafodvj.php
		function GetZoomFactor()
		{
			var factor = 1;
			if (document.body.getBoundingClientRect) {
				var rect = document.body.getBoundingClientRect ();
				var physicalW = rect.right - rect.left;
				var logicalW = document.body.offsetWidth;
				factor = Math.round ((physicalW / logicalW) * 100) / 100;
			}
			return factor;
		}
		var zoomFactor = GetZoomFactor();
		var scrollLeft = Math.round(document.documentElement.scrollLeft / zoomFactor);
		var scrollTop = Math.round(document.documentElement.scrollTop / zoomFactor);
	}

	select.style.position = "absolute";
	select.style.left = (rects[0].left + scrollLeft) + "px";
	select.style.top = (rects[0].top + scrollTop) + "px";
	select.style.zIndex = "1000000";

	var keydownFunc = function(e){
		e = e ? e : window.event;
		// Need to implement hiding select on "Escape" and "Enter".
		if (e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
			return 1;
		}
		// Escape, Enter.
		if (27 == e.keyCode || 13 == e.keyCode) {
			select.blur();
			return 0;
		}
		return 1;
	};

	if (select.addEventListener) {
		select.addEventListener("keydown", keydownFunc, false);
	} else {
		select.attachEvent("onkeydown", keydownFunc);
	}

	var tempID = window["ExpandSelect_tempID"];

	var clickFunc = function(e){
		e = e ? e : window.event;
		if (e.target) {
			if (e.target.tagName == "OPTION") {
				select.blur();
			}
		} else {
			// IE case.
			if (e.srcElement.tagName == "SELECT" || e.srcElement.tagName == "OPTION") {
				select.blur();
			}
		}
	};

	if (select.addEventListener) {
		select.addEventListener("click", clickFunc, false);
	} else {
		select.attachEvent("onclick", clickFunc);
	}

	var blurFunc = function(){
		if (select.removeEventListener) {
			select.removeEventListener("blur", arguments.callee, false);
			select.removeEventListener("click", clickFunc, false);
			select.removeEventListener("keydown", keydownFunc, false);
		} else {
			select.detachEvent("onblur", arguments.callee);
			select.detachEvent("onclick", clickFunc);
			select.detachEvent("onkeydown", keydownFunc);
		}
		select.size = 1;
		select.style.position = "static";
		select = select.parentNode.removeChild(select);
		var select2 = document.getElementById("ExpandSelect_"+tempID);
		select2.parentNode.insertBefore(select, select2);
		select2.parentNode.removeChild(select2);

	};

	if (select.addEventListener) {
		select.addEventListener("blur", blurFunc, false);
	} else {
		select.attachEvent("onblur", blurFunc);
	}

	document.body.appendChild(select);
	select.focus();
}